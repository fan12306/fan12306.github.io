<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/04/js数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/11/04/js数据结构/" itemprop="url">
                  js数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-04T11:18:16+08:00">
                2019-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/11/布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/10/11/布局/" itemprop="url">
                  布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-11T20:32:11+08:00">
                2019-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><h2 id="父元素"><a href="#父元素" class="headerlink" title="父元素"></a>父元素</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><ol>
<li><p>确定主轴方向</p>
</li>
<li><p>可选值 row row-reserve column column-reserve</p>
</li>
</ol>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><ol>
<li><p>项目内的对齐方式</p>
</li>
<li><p>可选值 flex-start flex-end center baseline space-around space-between</p>
</li>
</ol>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><ol>
<li>换行</li>
</ol>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><ol>
<li>是 flex-direction and flex-wrap 的简写属性</li>
</ol>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><ol>
<li><p>定义项目在交叉轴的对齐方式</p>
</li>
<li><p>可选值 flex-start flex-end center baseline stretch</p>
</li>
</ol>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><ol>
<li><p>定义在多轴上的项目对齐方式</p>
</li>
<li><p>可选值 flex-start flex-end center space-around space-between stretch</p>
</li>
</ol>
<h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><ol>
<li>定义项目的排列顺序，数值越小则排名越前，默认为 0</li>
</ol>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><ol>
<li><p>定义项目的放大属性，默认为 0， 也就是剩余的空间既不放大页不填满</p>
</li>
<li><p>如果所有的项目均为 1， 那么它们将平分剩余的空间， 如果有一个项目为 i， 其他的项目为 1， 前者占据的剩余空间是其他的两倍</p>
</li>
</ol>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><ol>
<li>定义项目的缩小属性， 默认为 1，如果所有项目都为 1， 那么都将等比例缩小。</li>
<li>如果一个项目值为 0， 其余都为 1， 那么前者不缩小</li>
</ol>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><ol>
<li>定义在分配多余空间之前，项目占据的剩余空间，计算主轴是否还有剩余空间。</li>
</ol>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><ol>
<li>允许某个项目一其他的项目不一样的对齐方式</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/10/03/webpack/" itemprop="url">
                  webpack
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-03T19:07:29+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><ol>
<li>webpack 是把整一个项目当做成一个整体，通过一个主文件，webpack 将从这个项目中所有依赖的文件，并且将他们他报成一个或者多个浏览器可识别的 js 文件</li>
</ol>
<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><ol>
<li><p>webpack 是我们的打包机，webpack-dev-server 会创建一个本地服务器，监听代码的修改，并且自动刷新修改后的结果。</p>
</li>
<li><p>需要在 webpack.config.js 中的 devServer 属性中配置：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contentBase, 为文件提供本地服务器</span><br><span class="line">port, 坚挺的端口，默认为8080</span><br><span class="line">inline， 设置为true，源文件发生变化自动刷新页面</span><br><span class="line">historyApiFallback, 依赖HTML5 API， 如果设置为true，所有页面跳转指向index.html</span><br><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: &apos;./dist&apos;, //本地服务器所加载页面的目录</span><br><span class="line">    port: 3000,</span><br><span class="line">    inline: true, //不跳转</span><br><span class="line">    historyApiFallback: true //实时刷新</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后我们在根目录下创建webpack。config.js,在“package.json”添加两个命令用于本地开发和生产发布：</span><br><span class="line"></span><br><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &apos;webpack-dev-server&apos;</span><br><span class="line">    &quot;build&quot;: &apos;webpack&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><ol>
<li>用来写入口文件，它将是整个依赖关系的根，它指示 webpack 应该从哪个模块开始入手，来作为其构建内部以来图的开始。入口文件较多时，把 entry 写成一个对象，默认为./src</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><ol>
<li>即使有多个入口文件，但是只有一个出口文件,告诉 webpack 在哪里输出他所创建的 bundles，也可指定 bundles 的名称，默认位置为./dist。整个应用节后都会呗编译到输出文件夹中去，之基础的属性包括 filename: (文件名) 和 path： （输出路径）必须是绝对路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename, 输出文件的名称</span><br><span class="line">path： 输出路径</span><br><span class="line"></span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(&apos;&apos;,&apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><ol>
<li><p>因为 webpack 只能处理 js 文件，像是 css，png，woff，xml 等等的文件类型，webpack 无法进行处理，因此 Loader 可以理解问 webpack 的编译器，使得 webpack 可以处理一些非 js 的文件，使用释放的 loader 可是实现这个功能，</p>
</li>
<li><p>webapck 中配置 loader 有两个属性：</p>
</li>
</ol>
<ul>
<li>test 属性: 标志有哪些后缀的文件应该被处理，是一个正则表达式</li>
<li>use 属性： 指定 test 类型的文件应该使用哪个 loader 惊醒预处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.export: &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: [&quot;style-loader&quot;, &quot;css-loader&quot;]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>该文件指定了所有的 css 文件在 import 的时候都必须经过 css-loader 的预处理，处理后才能在 javascript 模块中直接使用 import 语句导入 css 模块，使用钱需要 npm</li>
</ol>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ol>
<li>loader 用于转换非 javascript 的文件，而插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等。要是用一个插件，一般先 npm 安装 在配置文件中引入，最后将其实例化传递给 plugins 在数组属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.export: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><ol>
<li><p>production, 生产模式</p>
</li>
<li><p>development, 开发模式</p>
</li>
<li><p>webpack 会自动对代码进行涯叔等优化，上去了配置的麻烦</p>
</li>
</ol>
<h2 id="动态生成-bundle-js-和-index-html"><a href="#动态生成-bundle-js-和-index-html" class="headerlink" title="动态生成 bundle.js 和 index.html"></a>动态生成 bundle.js 和 index.html</h2><ol>
<li><p>动态生成就是至在打包后的模块名称内插入 hash 至，是的每一次生成的模块具有不同的名称，贰 index.html 之所以要动态是因为生成是因为每次打包生成的模块名称不同，所以在 HTML 文档内引入是也要更嗨标签，这样才能保险和功能每次都能引用到正确的 js 文件</p>
</li>
<li><p>动态生成 bundle 文件，是为了防止林兰其缓存机制阻碍文件的更新，在每次修改代码之后，文件名中的 hash 都会发生方法改变，强制浏览器进行刷新，获取当前最新的文件</p>
</li>
<li><p>添加 hash 至</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">    filaname: &quot;[name].[hash]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如何添加到 html 文件中</li>
</ol>
<ul>
<li>每一次打包过后文件的名称都会发生改变，html-webpack-plugin 的插件，可以自动生成 HTML 文件，安装到开发环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin --save-dev</span><br><span class="line"></span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.export: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(</span><br><span class="line">            //option配置</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>有用的配置 title</li>
</ol>
<h2 id="清理-dist-文件夹"><a href="#清理-dist-文件夹" class="headerlink" title="清理/dist 文件夹"></a>清理/dist 文件夹</h2><ol>
<li><p>由于每次生成的 js 文件都不同名，并且无法覆盖，都保存在/dist 下</p>
</li>
<li><p>使用 cleanWebpackPlugin 插件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const &#123;CleanWebpackPlugin&#125; from &apos;clean-webpack-plugin&apos;</span><br><span class="line">module.export: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new cleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><ol>
<li><p>source maps 进行调试，使得我们在浏览器中可以看到哦源代码，进而续航打断点调试<br>module.export: {<br>devtool: ‘source-map’<br>}</p>
</li>
<li><p>自动打包</p>
<ul>
<li>watch 模式</li>
<li>webpack-dev-server</li>
<li>webpack-dev-middleware</li>
</ul>
</li>
<li><p>热处理模块<br>devserver: {<br>hot: true<br>}<br>引入两个插件到 webpack 配置文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devserver: &#123;</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.NameModulePlugin()</span><br><span class="line">        new webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在入口文件上添加</span><br><span class="line">if(module.hot) &#123;</span><br><span class="line">    module.hot.accept(&apos;./print.js&apos;, function() &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/移动端适配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/09/29/移动端适配/" itemprop="url">
                  移动端适配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-29T17:18:29+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="关于物理像素、屏幕像素密度、-css-像素、设备像素比"><a href="#关于物理像素、屏幕像素密度、-css-像素、设备像素比" class="headerlink" title="关于物理像素、屏幕像素密度、 css 像素、设备像素比"></a>关于物理像素、屏幕像素密度、 css 像素、设备像素比</h2><h3 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h3><ol>
<li>简而言之就是设备最小的显示单元，显示设备的真实像素</li>
</ol>
<h3 id="屏幕像素密度（Pibel-Per-Inch-简称-ppi），单位是-dpi（dot-per-inch）"><a href="#屏幕像素密度（Pibel-Per-Inch-简称-ppi），单位是-dpi（dot-per-inch）" class="headerlink" title="屏幕像素密度（Pibel Per Inch 简称 ppi），单位是 dpi（dot per inch）"></a>屏幕像素密度（Pibel Per Inch 简称 ppi），单位是 dpi（dot per inch）</h3><ol>
<li>ppi 越高，则图像就会越来越清晰 分辨率/屏幕尺寸 = ppi</li>
</ol>
<h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><ol>
<li>相当于屏幕像素密度</li>
</ol>
<h3 id="retina-屏幕"><a href="#retina-屏幕" class="headerlink" title="retina 屏幕"></a>retina 屏幕</h3><p>1。 一个独立像素相当于两个物理像素，那么原本 iPone3 的网页能够占满的像素，在 iPone4 上只能有一半，因为 iPone4 上的屏幕像素比是原来的两倍。</p>
<h2 id="meta-媒体查询"><a href="#meta-媒体查询" class="headerlink" title="meta 媒体查询"></a>meta 媒体查询</h2><ol>
<li>name 属性： viewPort，content=””内容中设置一些数据，width= device-width, initial-scale=1.0, user-scalable= no</li>
</ol>
<h2 id="px-gt-vw或者vh"><a href="#px-gt-vw或者vh" class="headerlink" title="px =&gt; vw或者vh"></a>px =&gt; vw或者vh</h2><ol>
<li><p>搭建vue-cli脚手架</p>
</li>
<li><p>npm i lib-flexible 将import 进index.js文件</p>
</li>
<li><p>npm i postcss-pxtorem 添加插件（px =&gt; rem）</p>
</li>
<li><p>npm i postcss-px-to-viewport</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/20/异步Done！/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/09/20/异步Done！/" itemprop="url">
                  异步Done！
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-20T17:22:59+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异步与性能"><a href="#异步与性能" class="headerlink" title="异步与性能"></a>异步与性能</h1><h2 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h2><ul>
<li>只有一个现在进行，其余的则会将来执行</li>
<li>从现在到未来的‘等待’，最简单的方法是使用回调函数</li>
<li>任何时候只要把代码包装成一个函数形式，并且以事件执行，那么我们就创建了一个将来执行的块，也由此将程序引入异步</li>
</ul>
<h3 id="异步控制台"><a href="#异步控制台" class="headerlink" title="异步控制台"></a>异步控制台</h3><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul>
<li><p>所有环境都有共同的点（线程），它们提供了一种机制来处理程序中多个快的执行，且执行每块时调用的 javaScript 引擎，这总集中被称为事件循环</p>
</li>
<li><p>setTImeout()并没有把你的回调函数挂在事件循环队列中，他所做的事设定一个定时器。当定时器到时后，环境会把你的的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调 ，它的精度并不是很高</p>
</li>
</ul>
<ol>
<li>所有的同步任务都在主线程上执行形成一个任务栈</li>
<li>主线程之外还存在一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件</li>
<li>一旦执行栈中的所有同步任务完成，系统就会读取任务队列中看看还有那些事件，那些对应的异步任务结束等待状态进入执行栈开始执行</li>
</ol>
<h2 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h2><ul>
<li><p>异步是现在和将来的时间间隙，并行是关于能够同时发生的事情</p>
</li>
<li><p>并线计算最常见的工具就是进程与线程。进程和线程独立运行，并可能同时运行；在不同的处理器，甚至不同的计算机上，但多个线程能够贡献单个进程的内存</p>
</li>
<li><p>线程不会中断，但是并行的时候可能有两个不同的线程在运行，因此可能出现竞态</p>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li><p>可以看作是‘进程级’的并行。</p>
</li>
<li><p>JavaScript 一次只能处理一个事件，所以没有严格地同时发生，</p>
</li>
</ul>
<h3 id="非交互"><a href="#非交互" class="headerlink" title="非交互"></a>非交互</h3><ul>
<li>独立运行，不会相互影响</li>
</ul>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><ul>
<li>可能出现竞态，需要看谁先完成，可以通过协调来完成竟态条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var res = []</span><br><span class="line"></span><br><span class="line">function response(data) &#123;</span><br><span class="line">    if(data.url == &apos;&apos;) &#123;</span><br><span class="line">        res[0] = data</span><br><span class="line">    &#125;else if(data.url == &apos;&apos;) &#123;</span><br><span class="line">        res[1] = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以运用判断条件(a &amp;&amp; b) ，需要两个都请求到了才符合条件，江湖人称门</li>
<li>只有第一名取胜，成为竟态，可以通过！门来作为判断条件</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul>
<li>简单来说就是运行很大一个数据的时候我们需要将其分割为一部分一部分这样运行，不然用户体验效果很差</li>
</ul>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul>
<li><p>所有任务可以分成两种，一种是 同步任务（synchronous），另一种是 异步任务（asynchronous） 。</p>
<ul>
<li><p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p>
</li>
<li><p>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有 “任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
</li>
</ul>
</li>
</ul>
<p>所以，当在执行过程中遇到一些类似于 setTimeout 等异步操作的时候，会交给浏览器的其他模块进行处理，当到达 setTimeout 指定的延时执行的时间之后，回调函数会放入到任务队列之中。</p>
<p>当然，一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有任务执行完毕之后，接着去执行任务队列之中的回调函数。</p>
<h2 id="回调函数的两个问题和异步顺序"><a href="#回调函数的两个问题和异步顺序" class="headerlink" title="回调函数的两个问题和异步顺序"></a>回调函数的两个问题和异步顺序</h2><ol>
<li><p>控制反转问题</p>
</li>
<li><p>回调地狱问题</p>
</li>
<li><p>异步的顺序问题</p>
</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="控制反转反转"><a href="#控制反转反转" class="headerlink" title="控制反转反转"></a>控制反转反转</h3><ol>
<li><p>我们不把自己的程序交给第三方，而是希望第三方给我们提供了解其任务何时结束的能力，然后再由我们自己的代码来决定下一步做什么</p>
</li>
<li></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/前端面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/09/02/前端面试题/" itemprop="url">
                  前端面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-02T11:03:23+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h1><h2 id="html-与-css-类"><a href="#html-与-css-类" class="headerlink" title="html 与 css 类"></a>html 与 css 类</h2><h3 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h3><ol>
<li>block :　 CSS1 块对象的默认值。将对象强制作为块对象呈递，为对象之后添加新行 可以定义高度和宽度</li>
<li>none :　 CSS1 隐藏对象。与 visibility 属性的 hidden 值不同，其不为被隐藏的对象保留其物理空间</li>
<li>inline :　 CSS1 内联对象的默认值。将对象强制作为内联对象呈递，从对象中删除行</li>
<li>inline-block :　 IE5.5 将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内 inherit: 看 display 默认是不具备继承性的，使用 inherit 可以让其继承父对象的 display 属性。</li>
</ol>
<h3 id="overflow-属性"><a href="#overflow-属性" class="headerlink" title="overflow 属性"></a>overflow 属性</h3><ol>
<li>参数是 scroll 时候，必会出现滚动条。</li>
<li>参数是 auto 时候，子元素内容大于父元素时出现滚动条。</li>
<li>参数是 visible 时候，溢出的内容出现在父元素之外。</li>
<li>参数是 hidden 时候，溢出隐藏。</li>
</ol>
<h3 id="a-标签的-target-属性在何处打开链接文档"><a href="#a-标签的-target-属性在何处打开链接文档" class="headerlink" title="a 标签的 target 属性在何处打开链接文档"></a>a 标签的 target 属性在何处打开链接文档</h3><ol>
<li>_blank 在新窗口打开被链接文档</li>
<li>_self 默认 在相同的框架中打开被链接文档</li>
<li>_parent 在父框架集中打开被链接文档</li>
<li>_top 在整个窗口中打开被链接文档</li>
<li>framename 在指定的框架中打开被链接文档</li>
</ol>
<h3 id="clear-属性"><a href="#clear-属性" class="headerlink" title="clear 属性"></a>clear 属性</h3><ol>
<li>只能影响使用清楚的元素本身，不能影响其他元素。</li>
</ol>
<h3 id="alt-标签与-title-标签"><a href="#alt-标签与-title-标签" class="headerlink" title="alt 标签与 title 标签"></a>alt 标签与 title 标签</h3><ol>
<li>alt 是 html 标签的属性，而 title 既是 html 标签，又是 html 属性。</li>
<li>title 标签这个不用多说，网页的标题就是写在<title></title>这对标签之内的。</li>
<li>title 作为属性时，用来为元素提供额外说明信息。例如，给超链接标签 a 添加了 title 属性，把鼠标移动到该链接上面是，就会显示 title 的内容，以达到补充说明或者提示的效果。</li>
<li>而 alt 属性则是用来指定替换文字，只能用在 img、area 和 input 元素中（包括 applet 元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。</li>
</ol>
<h3 id="Document-与-html"><a href="#Document-与-html" class="headerlink" title="Document 与 html"></a>Document 与 html</h3><ol>
<li><!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。</html></li>
<li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li>
<li>DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ol>
<h3 id="Width-auto-amp-Width-100"><a href="#Width-auto-amp-Width-100" class="headerlink" title="Width: auto &amp; Width: 100%"></a>Width: auto &amp; Width: 100%</h3><ol>
<li><p>width: auto 其父元素的 content 的值为子元素的（content + padding + border + margin）</p>
</li>
<li><p>width: 100% 其父元素的 content 的值为子元素的（content） 因为子元素的 content 将其父元素 content 撑满，子元素的 border，padding， margin 则会被溢出父盒子。</p>
</li>
</ol>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ol>
<li><p>IE 模型： box-sizing: border-box 元素宽度 = border + padding + content</p>
</li>
<li><p>W3C 模型： box-sizing: content-box 元素宽度 = content</p>
</li>
</ol>
<h3 id="domContentLoaded-与-load"><a href="#domContentLoaded-与-load" class="headerlink" title="domContentLoaded 与 load"></a>domContentLoaded 与 load</h3><ol>
<li>domContentLoaded 事件早于 onload 事件<br>onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片，flash 都已经加载完成了，domContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash。</li>
</ol>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><ol>
<li>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。 在 HTML 4.01 中有三种 &lt;!DOCTYPE&gt; 声明。在 HTML5 中只有一种： <!DOCTYPE html></li>
</ol>
<h3 id="border-0-border-style-none"><a href="#border-0-border-style-none" class="headerlink" title="border: 0, border-style: none"></a>border: 0, border-style: none</h3><ol>
<li>border:none 表示边框样式无,border:0 表示边框宽度为 0;</li>
<li>当定义了 border:none,即隐藏了边框的显示,实际就是边框宽度为 0.</li>
<li>当定义边框时,必须定义边框的显示样式.因为边框默认样式为不显示 none,所以仅设置边框宽度,由于样式不存在,边框的宽度也自动被设置为 0.</li>
</ol>
<h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><ol>
<li>CSS Sprites 在国内很多人叫 css 精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。</li>
<li>利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字精确的定位出背景图片的位置。</li>
<li>利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能，这也是 CSS Sprites 最大的优点，也是其被广泛传播和应用的主要原因；<br>CSS Sprites 能减少图片的字节，曾经比较过多次 3 张图片合并成 1 张图片的字节总是小于这 3 张图片的字节总和。</li>
<li>解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。<br>更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。</li>
</ol>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="flash-接口与-js-的通信"><a href="#flash-接口与-js-的通信" class="headerlink" title="flash 接口与 js 的通信"></a>flash 接口与 js 的通信</h3><ol>
<li>Flash 提供了 ExternalInterface 接口与 JavaScript 通信 - 两个方法：call 和 addCallback - 作用：call 让 Flash 调用 js 里的方法，addCallback 是用来注册 flash 函数让 js 调用。 1. 什么是 Interpolator？<br>通俗易懂的说，Interpolator 负责控制动画变化的速率，使得基本的动画效果能够以匀速、加速、减速、抛物线速率等各种速率变化。</li>
</ol>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li>js 可以使用 jsonp 进行跨域 1. JSONP 由两部分组成：回调函数和数据 2. 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。 3. 数据是传入回调函数中的 JSON 数据。 - 优点：能够直接访问响应文本，可用于浏览器与服务器间的双向通信。 - 缺点：JSONP 从其他域中加载代码执行，其他域可能不安全；<br>难以确定 JSONP 请求是否失败。</li>
<li>通过修改 document.domain 来跨子域<ol>
<li>将页面的 document.domain 设置为相同的值，页面间可以互相访问对方的 JavaScript 对象。</li>
</ol>
<ul>
<li>注意：<ul>
<li>不能将值设置为 URL 中不包含的域；</li>
<li>松散的域名不能再设置为紧绷的域名。</li>
</ul>
</li>
</ul>
</li>
<li>使用 window.name 来进行跨域</li>
</ol>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><ol>
<li>Wekbit 是一个开源的 Web 浏览器引擎，也就是浏览器的内核。Apple 的 Safari, Google 的 Chrome, Nokia S60 平台的默认浏览器，Apple 手机的默认浏览器，Android 手机的默认浏览器均采用的 Webkit 作为器浏览器内核。Webkit 的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。另外两个分别是 Gecko 和 Trident，大名鼎鼎的 Firefox 便是使用的 Gecko 内核，而微软的 IE 系列则使用的是 Trident 内核。</li>
<li>另外，搜狗浏览器是双核的，双核并不是指一个页面由 2 个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由 webkit 内核处理,只有银行网站用 IE 内核</li>
</ol>
<h3 id="web-storage"><a href="#web-storage" class="headerlink" title="web storage"></a>web storage</h3><ol>
<li>sessionStorage：存储特定于某个会话的数据，该数据只保留到浏览器关闭。</li>
<li>globalStorage：目的是跨越会话存储数据，不过要指定哪些域可以访问该数据。如果不使用 removeItem() 或 delete 删除，或者用户未清除浏览器缓存，存储在 globalStorage 上的数据会一直保留在磁盘上。所以 globalStorage 非常适合在客户端存储文档或长期保留用户偏好设置。</li>
<li>localStorage：在 HTML5 中作为持久保持客户端数据的方案取代了 globalStorage。它不能被指定访问规则，要访问 localStorage，页面必须来自同一个域名，使用同一种协议，在同一个端口上。它的数据也保留到通过 JavaScript 删除或用户清除浏览器缓存。</li>
</ol>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ol>
<li><p>一些常见的状态码为：</p>
<ul>
<li>200 - 服务器成功返回网页</li>
<li>404 - 请求的网页不存在</li>
<li>503 - 服务不可用</li>
<li>1xx（临时响应）</li>
<li>2xx （成功）</li>
<li>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</li>
<li>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。</li>
<li>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</li>
</ul>
</li>
</ol>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ol>
<li>第一个字符必须是一个 ASCII 字母（大小写均可），或一个下划线(_)。注意第一个字符不能是数字。后续的字符必须是字母、数字或下划线。 变量名称一定不能是 保留字。</li>
</ol>
<h3 id="原型链（圆形、构造函数、实例、原型链）"><a href="#原型链（圆形、构造函数、实例、原型链）" class="headerlink" title="原型链（圆形、构造函数、实例、原型链）"></a>原型链（圆形、构造函数、实例、原型链）</h3><ol>
<li><p>Object.prototype 属性时整一个原型链的顶端</p>
</li>
<li><p>原型链通过 prototype 属性和<strong>proto</strong>属性来查找</p>
</li>
<li><p>所有引用类型都有对象特性，都有 proto 属性，函数有 prototype 属性</p>
</li>
<li><p>所有引用类型的 proto 类型都指向其构造函数的 prototype 属性</p>
</li>
<li><p>实例本身的属性哥方法如果没有找到，就会沿着原型链一直向上查找，直到找到，返回结构，如果找不到，返回 undefined</p>
</li>
</ol>
<h3 id="instanceOf-的原理"><a href="#instanceOf-的原理" class="headerlink" title="instanceOf 的原理"></a>instanceOf 的原理</h3><ol>
<li>实例对象的<strong>proto</strong>属性与构造函数的 prototype 属性，判断是否是同一个引用</li>
</ol>
<h3 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h3><ol>
<li><p>创建一个新的对象</p>
</li>
<li><p>继承构造函数的 prototype</p>
</li>
<li><p>指定 this 为新的对象</p>
</li>
<li><p>将新的=对象返回出去</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var new = function(func) &#123;</span><br><span class="line">     var o = Object.create(func.prototype);</span><br><span class="line">     var k = func.call(o)</span><br><span class="line">     if(typeOf k === &quot;Object) &#123;</span><br><span class="line">          return k</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">          return o</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volid"><a href="#volid" class="headerlink" title="volid()"></a>volid()</h3><ol>
<li>void() 是一个一元运算符，后面接的是表达式，void(0) 也是北方成void 0， 但是如果void() 后面没有则会报错</li>
</ol>
<h3 id="继承（本质上原型链"><a href="#继承（本质上原型链" class="headerlink" title="继承（本质上原型链"></a>继承（本质上原型链</h3><ol>
<li>组合继承</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol>
<li>作用域链是保证执行环境内有权访问变量和函数的有序的，作用域链的变量只能梁上访问，变量访问到 window 对象及被终止，作用域链乡下访问是不被允许的</li>
</ol>
<h3 id="类数组转化为真数组"><a href="#类数组转化为真数组" class="headerlink" title="类数组转化为真数组"></a>类数组转化为真数组</h3><ol>
<li><p>var arr = [].slice.call(arguments)</p>
</li>
<li><p>var arr = Array.prototype.slice.call(arguments)</p>
</li>
<li><p>var arr = Array.from(arguments)</p>
</li>
<li><p>var arr = […arguments]</p>
</li>
</ol>
<h3 id="实现-call"><a href="#实现-call" class="headerlink" title="实现 call"></a>实现 call</h3><ol>
<li><p>改变调用函数的 this 值</p>
</li>
<li><p>调用该函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj) &#123;</span><br><span class="line">     obj.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 = function(context) &#123;</span><br><span class="line">     if(! typeOf this === &apos;Function&apos;) &#123;</span><br><span class="line">          throw new error(&apos;wodiaoni&apos;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    let self = this</span><br><span class="line"></span><br><span class="line">    let args = Array.prototype.slice.call(arguments, 1)</span><br><span class="line">    var fBound = function() &#123;</span><br><span class="line">         let BindArgs = Array.prototype.slice.call(arguments)</span><br><span class="line">         self.apply(this instanceOf fBound ? this : context</span><br><span class="line">         , args.concat(BindArgs))</span><br><span class="line">     &#125;</span><br><span class="line">     let FON = function() &#123;&#125;</span><br><span class="line">     fBound.prototype = new FON()</span><br><span class="line">     FON.prototype = this.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><ol>
<li><p>可枚举属性</p>
<ul>
<li>原生状态下，挂载到Object下的属性是不可枚举的，直接Object下改在是可枚举的，因此一定要使用Object.defineProperty,来设置enumerable：false 可使用 getOwnPropertyDescriptor来查看配置</li>
</ul>
</li>
<li><p>判断参数是否正确 </p>
<ul>
<li>undefined 与 null 是一样的， 也就是说使用一个判断就可以了 target == null</li>
</ul>
</li>
<li><p>原始类型被包装成对象</p>
<ul>
<li>原始类型会被包装成对象，但是只有只有字符串对象才可能有可枚举属性</li>
<li>因此我们使用Object来对象化target</li>
<li>对象对于不可改写的属性值的修改静默失败，在严格模式下才会提示错误</li>
</ul>
</li>
<li><p>存在性</p>
<ul>
<li>如何在不访问属性值的情况下判断对象是否存在某个属性呢<ul>
<li>in操作符与hasOwnProperty方法</li>
<li>in操作符会访问原型对象上的属性，hasOwnProperty却不会</li>
</ul>
</li>
<li>Object.assign()不会访问原型链上的属性，但是我们不能直接使用hasOwnProperty来进行判断，因为可能有些对象并没有连接到Object.prototype，</li>
<li>因此我们选择使用for in来获取所有属性（包括原型上的属性），然后使用hasOwnProperty过滤掉原型上的属性</li>
</ul>
</li>
</ol>
<h1 id="执行上下文和执行栈"><a href="#执行上下文和执行栈" class="headerlink" title="执行上下文和执行栈"></a>执行上下文和执行栈</h1><h3 id="三种执行上下文类型"><a href="#三种执行上下文类型" class="headerlink" title="三种执行上下文类型"></a>三种执行上下文类型</h3><ol>
<li><p>全局执行上下文： 只有一个，js中是window ，node中是global。</p>
</li>
<li><p>函数执行上下文： 有无数个，当执行某个函数的时候就会相应地创建一个函数的执行上下文</p>
</li>
<li><p>eval 上下文： 不推荐</p>
</li>
</ol>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><h3 id="含义：-执行栈又叫作调用栈，用来储存和执行执行上下文"><a href="#含义：-执行栈又叫作调用栈，用来储存和执行执行上下文" class="headerlink" title="含义： 执行栈又叫作调用栈，用来储存和执行执行上下文"></a>含义： 执行栈又叫作调用栈，用来储存和执行执行上下文</h3><h3 id="执行栈的特点：后进先出，在执行js代码的时候，首先会创建全局执行上下文，并且-push-到栈底，每当执行一个函数的时候，就会创建一个函数执行栈，并且将它-push-到栈顶，当栈顶的函数执行完毕的时候，执行栈将执行完的函数执行上下文-pop-出，并且将控制权交给下一个执行上下文"><a href="#执行栈的特点：后进先出，在执行js代码的时候，首先会创建全局执行上下文，并且-push-到栈底，每当执行一个函数的时候，就会创建一个函数执行栈，并且将它-push-到栈顶，当栈顶的函数执行完毕的时候，执行栈将执行完的函数执行上下文-pop-出，并且将控制权交给下一个执行上下文" class="headerlink" title="执行栈的特点：后进先出，在执行js代码的时候，首先会创建全局执行上下文，并且 push 到栈底，每当执行一个函数的时候，就会创建一个函数执行栈，并且将它 push 到栈顶，当栈顶的函数执行完毕的时候，执行栈将执行完的函数执行上下文 pop 出，并且将控制权交给下一个执行上下文"></a>执行栈的特点：后进先出，在执行js代码的时候，首先会创建全局执行上下文，并且 push 到栈底，每当执行一个函数的时候，就会创建一个函数执行栈，并且将它 push 到栈顶，当栈顶的函数执行完毕的时候，执行栈将执行完的函数执行上下文 pop 出，并且将控制权交给下一个执行上下文</h3><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>先确定 this 的指向</p>
</li>
<li><p>词法环境：包括环境记录以及对外环境引用</p>
<ol>
<li><p>环境记录：储存变量和函数的实际位置</p>
</li>
<li><p>对外环境引用：可以访问其他词法环境</p>
</li>
</ol>
</li>
<li><p>变量环境： 也是词法环境拥有一样的属性</p>
</li>
<li><p>区别: 词法环境与变量环境的区别主要在于前者用来存储函数声明和变量绑定的，后者仅仅用于变量绑定</p>
</li>
</ol>
<h3 id="变量提升的原因"><a href="#变量提升的原因" class="headerlink" title="变量提升的原因"></a>变量提升的原因</h3><ol>
<li>在创建阶段，函数声明储存在环境中，但是var是变量环境，因此默认为undefined, 但是let ,const 声明的则是未初始化的状态，因此会报错</li>
</ol>
<h1 id="内存空间详解"><a href="#内存空间详解" class="headerlink" title="内存空间详解"></a>内存空间详解</h1><h2 id="栈、堆、队列数据结构"><a href="#栈、堆、队列数据结构" class="headerlink" title="栈、堆、队列数据结构"></a>栈、堆、队列数据结构</h2><ol>
<li><p>栈：后进先出；</p>
</li>
<li><p>堆：类似对象结构，像是书架，只需要知道书本的名字，就可以直接获取到书籍</p>
</li>
<li><p>队列：先进后出</p>
</li>
</ol>
<h2 id="变量存放"><a href="#变量存放" class="headerlink" title="变量存放"></a>变量存放</h2><h3 id="基本类型有：String-Null-Undefined-Boolean-Number-Symbol，存放在栈中，分别站有固定的空间大小"><a href="#基本类型有：String-Null-Undefined-Boolean-Number-Symbol，存放在栈中，分别站有固定的空间大小" class="headerlink" title="基本类型有：String, Null, Undefined, Boolean, Number, Symbol，存放在栈中，分别站有固定的空间大小"></a>基本类型有：String, Null, Undefined, Boolean, Number, Symbol，存放在栈中，分别站有固定的空间大小</h3><h3 id="引用类型：Object，存放在堆中，没有固定的空间大小，但是内存地址是固定的空间大小，因此内存地址保存在栈中。当询问引用类型的变量的时候先去栈中查询变量的内存地址，再去堆中获取变量的值。我们称为引用访问"><a href="#引用类型：Object，存放在堆中，没有固定的空间大小，但是内存地址是固定的空间大小，因此内存地址保存在栈中。当询问引用类型的变量的时候先去栈中查询变量的内存地址，再去堆中获取变量的值。我们称为引用访问" class="headerlink" title="引用类型：Object，存放在堆中，没有固定的空间大小，但是内存地址是固定的空间大小，因此内存地址保存在栈中。当询问引用类型的变量的时候先去栈中查询变量的内存地址，再去堆中获取变量的值。我们称为引用访问"></a>引用类型：Object，存放在堆中，没有固定的空间大小，但是内存地址是固定的空间大小，因此内存地址保存在栈中。当询问引用类型的变量的时候先去栈中查询变量的内存地址，再去堆中获取变量的值。我们称为引用访问</h3><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除：-从全局对象中想内存中的对象进行扫描，凡是能到达根部的对象，那些从根部无法到达的对象被标记为不再使用，稍后被垃圾回收"><a href="#标记清除：-从全局对象中想内存中的对象进行扫描，凡是能到达根部的对象，那些从根部无法到达的对象被标记为不再使用，稍后被垃圾回收" class="headerlink" title="标记清除： 从全局对象中想内存中的对象进行扫描，凡是能到达根部的对象，那些从根部无法到达的对象被标记为不再使用，稍后被垃圾回收"></a>标记清除： 从全局对象中想内存中的对象进行扫描，凡是能到达根部的对象，那些从根部无法到达的对象被标记为不再使用，稍后被垃圾回收</h3><h3 id="四种常见的内存泄漏"><a href="#四种常见的内存泄漏" class="headerlink" title="四种常见的内存泄漏"></a>四种常见的内存泄漏</h3><ol>
<li><p>意外的全局变量</p>
</li>
<li><p>被遗忘的回调函数以及计时器</p>
</li>
<li><p>脱离dom的引用</p>
</li>
<li><p>闭包</p>
</li>
</ol>
<h3 id="从内存上看null与undefined的区别："><a href="#从内存上看null与undefined的区别：" class="headerlink" title="从内存上看null与undefined的区别："></a>从内存上看null与undefined的区别：</h3><ol>
<li><p>某个全局变量被赋值为null，则说明相当于将该变量的指针和值都清空，如果是给对象的属性赋值为null,局部变量为null，相当给这个属性的内存分配了一个空的内存。</p>
</li>
<li><p>给全局变量赋值为undefined，相当于将这个值清空</p>
</li>
</ol>
<h1 id="从作用域链看闭包"><a href="#从作用域链看闭包" class="headerlink" title="从作用域链看闭包"></a>从作用域链看闭包</h1><ol>
<li>含义：能够访问其他函数里的变量的函数</li>
</ol>
<h2 id="作用域说闭包"><a href="#作用域说闭包" class="headerlink" title="作用域说闭包"></a>作用域说闭包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getData() &#123;</span><br><span class="line">     var count = 1</span><br><span class="line">     function addCount() &#123;</span><br><span class="line">          return count + 1</span><br><span class="line">     &#125;</span><br><span class="line">     return addCount</span><br><span class="line">&#125;</span><br><span class="line">var counter = getData()</span><br><span class="line">counter()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行过程：</p>
<ol>
<li><p>进入全局代码，将全局上下文压入执行栈</p>
</li>
<li><p>执行getData() 函数，创建getData() 函数执行上下文，并且将其压入执行栈中</p>
</li>
<li><p>执行完getData() 函数，返回 addCount 函数给counter，并且将getData() 推出执行栈</p>
</li>
<li><p>执行counter() 函数，创建 addCount 函数执行上下文，并且将其压入执行栈中</p>
</li>
<li><p>执行完了，将其推出执行栈</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>问题：引文getData 函数上下文已经销毁，那么他是如何获取到count 的值。<ol>
<li>虽然函数执行上下文已经销毁，但是通过作用域链，我们还是可以访问到函数的活动对象，JavaStript 会让活动对象保存在内存中</li>
</ol>
</li>
</ul>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><ol>
<li><p>js的执行上下文</p>
<ul>
<li>在js中，一共有三个执行上下文，一个是全局执行上下文，一个是函数执行上下文，还有一个 Eval ，刚开始执行js代码的时候就会产生一个全局执行作用域，并将其推入栈底，每当执行一个函数就会产生一个执行上下文，并且将其推入执行栈顶，</li>
</ul>
</li>
<li><p>执行栈</p>
<ul>
<li>用来储存代码运行时创建的执行上下文，执行栈具有栈的结构特定— 后进先出</li>
</ul>
</li>
<li><p>如何创建执行上下文</p>
<ol>
<li>this值的绑定；</li>
<li>创建词法环境组件；</li>
<li>创建变量环境组件；</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/01/项目开发3-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/09/01/项目开发3-0/" itemprop="url">
                  Untitled
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:04+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="项目开发-3-0"><a href="#项目开发-3-0" class="headerlink" title="项目开发 3.0"></a>项目开发 3.0</h1><h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>props 主要是从外部可以控制内部基础组件的一个途径</p>
</li>
<li><p>基础组件只是负责样式和基本的传值，并不参于业务逻辑方面的编写。</p>
</li>
<li><p>利用 slot 插入基础组件包括的 dom 对象</p>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>轮播图实现需要考虑的东西<ol>
<li>轮播图的展示长度，</li>
<li>轮播图一共的总长度 记得加 px</li>
<li>如果实现 loop 无缝，那么会在头和尾之中多插入一张图，因此会多两个图片的长度</li>
<li>应用样式 — 这个是为每个 item 应用的样式，很关键</li>
</ol>
</li>
</ol>
<h2 id="scroll-组件的抽离"><a href="#scroll-组件的抽离" class="headerlink" title="scroll 组件的抽离"></a>scroll 组件的抽离</h2><ol>
<li><p>props 的设置，主要考虑该组件能干什么。</p>
</li>
<li><p>初始化 scroll 组件</p>
<ol>
<li>把传入的 props 定义好；</li>
<li>代理方法 最主要的是 refresh()方法</li>
</ol>
</li>
<li><p>watch:data 的变化，并且 refresh</p>
</li>
<li><p>scroll 实现需要两个条件</p>
<ol>
<li>scroll 下的第一个 div 才能实现 scroll；</li>
<li>高度必须满足高过父元素；</li>
<li>父组件需要固定定位</li>
</ol>
</li>
<li><p>渲染时间 若在轮播图下初始化 scroll，还需要注意异步获取的作用，因为轮播图的数据和列表的数据都是异步获取的，因此我们需要在重新 refresh(),可能在列表获取玩的时候，轮播图的图片才获取，但是这时 scroll 的组件已经 refresh 过了，因此列表会缺少轮播图高度的高度。因此我们还需要做一次判断</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@load=&apos;loadImage&apos;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    loadImage() &#123;</span><br><span class="line">        if(this.checkLoaded) &#123;</span><br><span class="line">            this.$refs.scroll.refresh()</span><br><span class="line">            this.checkLoaded = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这个方法也是实现一个执行常用的方法，请务必记住！！</span><br><span class="line">当仅仅只有一张图片有了之后我们就可以撑开父元素的高度了</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>懒加载和 loading 效果都不是很难</p>
<ol>
<li><p>懒加载主要是配置方面可能会生疏，但是可以查相关文档就好</p>
<ul>
<li>分为 4 个步骤<ol>
<li>安装依赖</li>
<li>导入 index.js 中</li>
<li>注册</li>
<li>应用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. npm i vue-lazy-loader</span><br><span class="line">2. import VueLazyLoad from &apos;vue-lazyload&apos;</span><br><span class="line">3. Vue.use(VueLazyLoad, &#123;</span><br><span class="line">    loading: require(&apos;需要加载的图片地址&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">4. 将img中src属性更换成v-lazy即可</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>loading 与其他的基础组件一样，他仅仅只有一张图，但是 loading 的使用事件很关键，需要在数据尚未获取的时候应用<code>v-show=&#39;singer.length &lt;= 0&#39;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="歌手数据的处理"><a href="#歌手数据的处理" class="headerlink" title="歌手数据的处理"></a>歌手数据的处理</h2><ol>
<li>因为我们获取的数据与我们想要的数据结构不一样，因此我们需要修改为我们想要的数据结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map =&gt; hot 与 A 、B 、C</span><br><span class="line">每一个子数据下面拥有 title 和 items的数据结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    normalizeSigner(list) &#123;</span><br><span class="line">        let map = &#123;</span><br><span class="line">            hot: &#123;</span><br><span class="line">                title: HOT_POINT,</span><br><span class="line">                items: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.forEach((item, index) =&gt; &#123;</span><br><span class="line">            if(index &lt;  HOT_LEN) &#123;</span><br><span class="line">                map.items.push(new Singer(&#123;</span><br><span class="line">                    id: item.Fsinger_min,</span><br><span class="line">                    name: item.Fsigner_name</span><br><span class="line">                &#125;))</span><br><span class="line">            &#125;</span><br><span class="line">            const key = item.Findex</span><br><span class="line">            if(!map[key]) &#123;</span><br><span class="line">                map[key] = &#123;</span><br><span class="line">                    title: key,</span><br><span class="line">                    items: []</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map[key].items.push(new Singer(&#123;</span><br><span class="line">                id: item.Fsinger_mid,</span><br><span class="line">                name: item.Fsinger.name</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">        let hot = []</span><br><span class="line">        let ret = []</span><br><span class="line">        for(let key in map) &#123;</span><br><span class="line">//我们比较的是val中title并不是key中的title，并且push进去的是值，不是key</span><br><span class="line">            const val = map[key]</span><br><span class="line">            if(val.title.match(/[a-zA-Z]/)) &#123;</span><br><span class="line">                ret.push(val)</span><br><span class="line">            &#125;else if(val.title === HOT_POINT) &#123;</span><br><span class="line">                hot.push(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.sort((a, b) =&gt; &#123;</span><br><span class="line">            return a.title.charCodeAt(0) - b.title.charCodeAt(0)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return  hot.concat(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    先要明确自己需要什么样的数据结构，才能一步一步做出来</span><br><span class="line">    根据数据的一个属性聚集这个方法要记牢</span><br><span class="line">    const key = item.FIndex</span><br><span class="line">    if(!map[key] &#123;</span><br><span class="line">        map[key] = &#123;</span><br><span class="line">            title: key,</span><br><span class="line">            items: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="右侧导航条的实现"><a href="#右侧导航条的实现" class="headerlink" title="右侧导航条的实现"></a>右侧导航条的实现</h2><h3 id="获取右侧的-index"><a href="#获取右侧的-index" class="headerlink" title="获取右侧的 index"></a>获取右侧的 index</h3><ol>
<li>因为 index 只有在 v-for 中获取，因此我们需要通过 getData 来获取</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default function getData(el, name, val) &#123;</span><br><span class="line">    const prefix = &apos;data-&apos;</span><br><span class="line">    if(val) &#123;</span><br><span class="line">        el.setAttribute(prefix + name, val)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        el.getAttribute(prefix + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也就是我们需要获取index的值，我们需要通过e.target.getAttribute来获取，很关键</span><br><span class="line">scrollToElement(el, time, offsetX, offsetY, easing), 也就是说我们需要获取使用时，要为其绑定this对象，apply方法</span><br><span class="line">使用方法为，因为是better-scroll的方法，必须有scroll的引用使用，并且需要跳转的element还需要绑定index</span><br></pre></td></tr></table></figure>

<h3 id="点击跳跃锚点到具体位置"><a href="#点击跳跃锚点到具体位置" class="headerlink" title="点击跳跃锚点到具体位置"></a>点击跳跃锚点到具体位置</h3><ol>
<li>利用到的事件为@touchstart, 主要难点为配置，使用 BScroll 和获取右侧列表的 index</li>
</ol>
<h3 id="滑动描点到具体位置"><a href="#滑动描点到具体位置" class="headerlink" title="滑动描点到具体位置"></a>滑动描点到具体位置</h3><ol>
<li><p>需要创建数据传输的对象，在 created 中创建，因为 data 中有 getter 和 setter，我们并不需要检测它们数据的变化。</p>
</li>
<li><p>滑动时候必须记录的数据，滑动前后的 index， 当前的滑动的距离。</p>
</li>
<li><p>调用 scrollToElement(el, time, offsetX, offsetY, easing)</p>
</li>
</ol>
<h3 id="创建样式与-listGroup-联动"><a href="#创建样式与-listGroup-联动" class="headerlink" title="创建样式与 listGroup 联动"></a>创建样式与 listGroup 联动</h3><ol>
<li><p>先获取到滚动列表的实时滚动位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listenScroll: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: false</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 基础组件派发出实时的pos --&gt;</span><br><span class="line">if(listenScroll) &#123;</span><br><span class="line">    this.scroll.on(&apos;scroll&apos;, (pos) =&gt; &#123;</span><br><span class="line">        this.$emit(&apos;scroll&apos;, pos)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算出每个表格的之间的高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@scroll= &apos;scroll&apos;</span><br><span class="line">   data() &#123;</span><br><span class="line">       return &#123;</span><br><span class="line">           scrollY: -1</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   created() &#123;</span><br><span class="line">       this.listHeight = []</span><br><span class="line">   &#125;</span><br><span class="line">   methods: &#123;</span><br><span class="line">       scroll(pos) &#123;</span><br><span class="line">           this.scrollY = pos.y</span><br><span class="line">       &#125;,</span><br><span class="line">       _calculateHeight() &#123;</span><br><span class="line">           const height = 0</span><br><span class="line">           const list = this.$refs.listGroup</span><br><span class="line">           this.listHeight.push(height)</span><br><span class="line">           for(let i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">               item = list[i]</span><br><span class="line">               let height += item.clientHeight</span><br><span class="line">               this.listHeight.push(height)</span><br><span class="line">           &#125;</span><br><span class="line">           return</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   watch: &#123;</span><br><span class="line">       data() &#123;</span><br><span class="line">           setTimeout(() =&gt; &#123;</span><br><span class="line">               this._calculate()</span><br><span class="line">           &#125;, 20)</span><br><span class="line">       &#125;,</span><br><span class="line">       scrollY(newY) &#123;</span><br><span class="line">           const listHeight = this.listHeight</span><br><span class="line">           if(newY &gt; 0) &#123;</span><br><span class="line">               this.currentIndex = 0</span><br><span class="line">               return</span><br><span class="line">           &#125;</span><br><span class="line">           for(let i = 0; i &lt; listHeight.length - 1; i++) &#123;</span><br><span class="line">               let height1 = listHeight[i]</span><br><span class="line">               let height2 = listHeight[i + 1]</span><br><span class="line">               if(-newY &gt; height1 &amp;&amp; -newY &lt; height2) &#123;</span><br><span class="line">                   this.currentIndex = i</span><br><span class="line">                   return</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           this.currentIndex = this.listHeight.length - 2</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加样式<br>:class=”{‘current’: currentIndex === index}”</p>
</li>
<li><p>边缘处理</p>
</li>
</ol>
<h2 id="fixTitle"><a href="#fixTitle" class="headerlink" title="fixTitle"></a>fixTitle</h2><h3 id="event-事件"><a href="#event-事件" class="headerlink" title="event 事件"></a>event 事件</h3><ol>
<li>x,y 事件发生的位置的 x 坐标和 y 坐标，它们相对于用 CSS 动态定位的最内层包容元素。</li>
</ol>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">鼠标 / 键盘属性</span><br><span class="line">    altKey	        返回当事件被触发时，&quot;ALT&quot; 是否被按下。</span><br><span class="line">    button	        返回当事件被触发时，哪个鼠标按钮被点击。</span><br><span class="line">    clientX	        返回当事件被触发时，鼠标指针的水平坐标。</span><br><span class="line">    clientY	        返回当事件被触发时，鼠标指针的垂直坐标。</span><br><span class="line">    ctrlKey	        返回当事件被触发时，&quot;CTRL&quot; 键是否被按下。</span><br><span class="line">    metaKey	        返回当事件被触发时，&quot;meta&quot; 键是否被按下。</span><br><span class="line">    relatedTarget	返回与事件的目标节点相关的节点。</span><br><span class="line">    screenX	        返回当某个事件被触发时，鼠标指针的水平坐标。</span><br><span class="line">    screenY	        返回当某个事件被触发时，鼠标指针的垂直坐标。</span><br><span class="line">    shiftKey	    返回当事件被触发时，&quot;SHIFT&quot; 键是否被按下。</span><br><span class="line"></span><br><span class="line">事件句柄</span><br><span class="line">    onabort	        图像的加载被中断。</span><br><span class="line">    onblur	        元素失去焦点。</span><br><span class="line">    onchange	    域的内容被改变。</span><br><span class="line">    onclick	        当用户点击某个对象时调用的事件句柄。</span><br><span class="line">    ondblclick	    当用户双击某个对象时调用的事件句柄。</span><br><span class="line">    onerror	        在加载文档或图像时发生错误。</span><br><span class="line">    onfocus	        元素获得焦点。</span><br><span class="line">    onkeydown	    某个键盘按键被按下。</span><br><span class="line">    onkeypress	    某个键盘按键被按下并松开。</span><br><span class="line">    onkeyup	        某个键盘按键被松开。</span><br><span class="line">    onload	        一张页面或一幅图像完成加载。</span><br><span class="line">    onmousedown	    鼠标按钮被按下。</span><br><span class="line">    onmousemove	    鼠标被移动。</span><br><span class="line">    onmouseout	    鼠标从某元素移开。</span><br><span class="line">    onmouseover	    鼠标移到某元素之上。</span><br><span class="line">    onmouseup	    鼠标按键被松开。</span><br><span class="line">    onreset	        重置按钮被点击。</span><br><span class="line">    onresize	    窗口或框架被重新调整大小。</span><br><span class="line">    onselect	    文本被选中。</span><br><span class="line">    onsubmit	    确认按钮被点击。</span><br><span class="line">    onunload	    用户退出页面。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>fixedTitle 中固定到 fixedTitle，通过计算属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixedTitle() &#123;</span><br><span class="line">    return this.data[this.currentIndex] ? this.data[this.currentIndex] : &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="diff-计算-fixedTop-高度"><a href="#diff-计算-fixedTop-高度" class="headerlink" title="diff()计算 fixedTop 高度"></a>diff()计算 fixedTop 高度</h3><ol>
<li>因为我们需要 diff 的实时更新值，diff= height2 - newY, 知道 newY 值一定要是哪个高度</li>
</ol>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    diff(newVal) &#123;</span><br><span class="line">        let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; HEIGHT_TOP) ? newVal - HEIGHT_TOP : 0</span><br><span class="line">        if(this.fixedTop === fixedTop) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        this.fixedTop = fixedTop</span><br><span class="line">        this.$refs.fixedTitle.style.transform = `translate3d(0, $&#123;fixedTop&#125;px, 0)`</span><br><span class="line">        不能忘记px</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="歌手列表获取"><a href="#歌手列表获取" class="headerlink" title="歌手列表获取"></a>歌手列表获取</h2><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default jsonp(url, data, options) &#123;</span><br><span class="line">    let url = &apos;&apos;</span><br><span class="line">    let data = Object.assign(&#123;&#125;, commonParams, &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    return jsop(url, data, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h3><ol>
<li><p>要学会使用 class 来进行数据的处理</p>
</li>
<li><p>我们需要一次性的把数据处理完毕，因此我们可以在构建一个函数</p>
</li>
</ol>
<h3 id="如何从一堆相同结构的数据中获取某一个对象-解构赋值"><a href="#如何从一堆相同结构的数据中获取某一个对象-解构赋值" class="headerlink" title="如何从一堆相同结构的数据中获取某一个对象(解构赋值)"></a>如何从一堆相同结构的数据中获取某一个对象(解构赋值)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_normalizeSongList(list) &#123;</span><br><span class="line">    const ret = []</span><br><span class="line">    list.forEach((item) =&gt; &#123;</span><br><span class="line">        let &#123;musicData&#125; = item //解构赋值很关键</span><br><span class="line">        if(musicData.songid &amp;&amp; musicData.albummid) &#123;</span><br><span class="line">            ret.push(musicData)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">        return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/better-scroll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/25/better-scroll/" itemprop="url">
                  better-scroll
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T19:29:34+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="better-scroll"><a href="#better-scroll" class="headerlink" title="better-scroll"></a>better-scroll</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="作用：重点解决移动端的各种滚动场景的需求"><a href="#作用：重点解决移动端的各种滚动场景的需求" class="headerlink" title="作用：重点解决移动端的各种滚动场景的需求"></a>作用：重点解决移动端的各种滚动场景的需求</h3><h3 id="作用区域"><a href="#作用区域" class="headerlink" title="作用区域"></a>作用区域</h3><ol>
<li>better-scroll 是作用在外层 wrapper 容器上的，滚动的部分是 content 元素。这里要注意的是，better-scroll 只处理容器（wrapper）的第一个子元素（content）的滚动，其它的元素都会被忽略。</li>
</ol>
<h2 id="滚动原理"><a href="#滚动原理" class="headerlink" title="滚动原理"></a>滚动原理</h2><h3 id="父元素的固定高度要低于子元素的高度"><a href="#父元素的固定高度要低于子元素的高度" class="headerlink" title="父元素的固定高度要低于子元素的高度"></a>父元素的固定高度要低于子元素的高度</h3><h2 id="选项-基础"><a href="#选项-基础" class="headerlink" title="选项/基础"></a>选项/基础</h2><ol>
<li>better-scroll 支持很多的参数配置，可以在初始化的时候传入第二个参数，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let scroll = new BScroll(&apos;wrapper&apos; &#123;</span><br><span class="line">    scrollY: true,</span><br><span class="line">    click: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样就可实现纵向可点击活动效果</p>
<h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><ol>
<li><p>startX</p>
<ul>
<li>type: Number,</li>
<li>default: 0,</li>
<li>function: 横轴方向初始化位置</li>
<li>function： 纵轴方向初始化位置（starY）</li>
</ul>
</li>
<li><p>scrollX</p>
<ul>
<li>type: Boolean,</li>
<li>default: false,</li>
<li>function: 当设置为 true 的时候，可以开启横向滚动</li>
<li>function： 当设置为 true 的时候，可以开启纵向滚动（scrollY）</li>
</ul>
</li>
<li><p>freeScroll</p>
<ul>
<li>type：Boolean，</li>
<li>default: false,</li>
<li>function: 不限制滚动的方向</li>
</ul>
</li>
<li><p>click: true 是否派发 click 事件，通常判断浏览器派发的 click 还 betterscroll 派发的 click，可以用_constructed，若是 bs 派发的则为 true</p>
</li>
<li><p>directionLockThreshold: 5</p>
</li>
<li><p>momentum: true 当快速滑动时是否开启滑动惯性</p>
</li>
<li><p>bounce: true 是否启用回弹动画效果</p>
</li>
<li><p>selectedIndex: 0 wheel 为 true 时有效，表示被选中的 wheel 索引</p>
</li>
<li><p>rotate: 25 wheel 为 true 时有效，表示被选中的 wheel 每一层的旋转角度</p>
</li>
<li><p>wheel: false 该属性是给 picker 组件使用的，普通的列表滚动不需要配置</p>
</li>
<li><p>snap: false 该属性是给 slider 组件使用的，普通的列表滚动不需要配置</p>
</li>
<li><p>snapLoop: false 是否可以无缝循环轮播</p>
</li>
<li><p>snapThreshold: 0.1 用手指滑动时页面可切换的阈值，大于这个阈值可以滑动的下一页</p>
</li>
<li><p>snapSpeed: 400, 轮播图切换的动画时间</p>
</li>
<li><p>swipeTime: 2500 swipe 持续时间</p>
</li>
<li><p>bounceTime: 700 弹力动画持续的毫秒数</p>
</li>
<li><p>adjustTime: 400 wheel 为 true 有用，调整停留位置的时间</p>
</li>
<li><p>swipeBounceTime: 1200 swipe 回弹 时间</p>
</li>
<li><p>deceleration: 0.001 滚动动量减速越大越快，建议不大于 0.01</p>
</li>
<li><p>momentumLimitTime: 300 符合惯性拖动的最大时间</p>
</li>
<li><p>momentumLimitDistance: 15 符合惯性拖动的最小拖动距离</p>
</li>
<li><p>resizePolling: 60 重新调整窗口大小时，重新计算</p>
</li>
<li><p>better-scroll 的时间间隔</p>
</li>
<li><p>preventDefault: true 是否阻止默认事件</p>
</li>
<li><p>preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ } 阻止默认事件</p>
</li>
<li><p>HWCompositing: true 是否启用硬件加速</p>
</li>
<li><p>useTransition: true 是否使用 CSS3 的 Transition 属性</p>
</li>
<li><p>useTransform: true 是否使用 CSS3 的 Transform 属性</p>
</li>
<li><p>probeType: 1 滚动的时候会派发 scroll 事件，会截流。2 滚动的时候实时派发 scroll 事件，不会截流。 3 除了实时派发 scroll 事件，在 swipe 的情况下仍然能实时派发 scroll 事件</p>
</li>
</ol>
<h2 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events 事件"></a>Events 事件</h2><ol>
<li>beforeScrollStart 滚动开始之前触发</li>
<li>scrollStart 滚动开始时触发</li>
<li>scroll 滚动时触发</li>
<li>scrollCancel 取消滚动时触发</li>
<li>scrollEnd 滚动结束时触发</li>
<li>touchend 手指移开的时候触发</li>
<li>flick 触发了 fastclick 的时候触发</li>
<li>refresh 当 better-scroll 刷新的时候触发</li>
<li>destroy 销毁的 better-scroll 的时候触发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">cosnt scroll = new BScroll($this.$refs.wrapper,&#123;</span><br><span class="line">    probeType : 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">scroll.on(&apos;scrollEnd&apos;,(pos) =&gt; &#123;</span><br><span class="line">    console.log(pos)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h2><ol>
<li><p>scrollTo(x,y,time,easing) 滚动到某个位置 x,y 代表坐标，time 表示动画的时间，easing 表示混动函数的，scroll.scrollTo(0,500)</p>
</li>
<li><p>scrollToElement(el,time,offsetX,offsetY,easing)表示滚动到某个 el ，el 代表的是 dom 元素，time 表示动画时间，offsetX 与 offsetY 表示坐标偏移量，easing 表示缓动动画</p>
</li>
<li><p>refresh（） 强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法</p>
</li>
<li><p>getCurrentPage() 当 snap 为 true 时，获取滚动的当前页面，返回对象的结构为(x, y, pageX, pageY),其中 x，y 代表滚动横向哥纵向的位置：pageX，pageY 表示横向和纵向的页面索引，用法为 scroll.getCurrentPage().pageX</p>
</li>
<li><p>goToPage(x, y, time, easing) snap 为 true 滚动到对应的页面，x 表示横向页面索引，y 表示纵向索引，time 表示动画，easing 表示缓动函数</p>
</li>
<li><p>enable() 启用 better-scroll, 默认开启</p>
</li>
<li><p>disable 禁用 better-scroll</p>
</li>
<li><p>destroy 销毁 better-scroll，解绑时间</p>
</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>better-scroll 的初始化时机很重要，因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动。因此，我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用 scroll.refresh() 方法重新计算来确保滚动效果的正常。所以同学们反馈的 better-scroll 不能滚动的原因多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构发送变化的时候并没有重新计算 better-scroll。</p>
</li>
<li><p>Vue 为我们提供了获取 DOM 对象的接口—vue$refs，并且我们澡 mounted 的时候初始化 better-scroll，这个时候都渲染好了，我们可以正确计算 content 的正确高度</p>
</li>
<li><p>为了确保 DOM 已经完全渲染，可以演示 20 毫秒</p>
</li>
</ol>
<h2 id="scroll-组件的抽象和封装"><a href="#scroll-组件的抽象和封装" class="headerlink" title="scroll 组件的抽象和封装"></a>scroll 组件的抽象和封装</h2><ol>
<li>JS 的部分实际上就是对 better-scroll 座一层 Vue 的封装，通过 props 的形式，把一些的 better-scroll 定制化的控制权交给父组件，通过 methods 暴露一些方法对 better-scroll 的方法做一层代理，通过 watch 传入的 data，重新 refresh 确保滚动正常， 父组件只需要把数据通过 data 通过 props 传给 scroll 组件，觉可以保证组件的滚动效果</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/项目开发2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/15/项目开发2-0/" itemprop="url">
                  项目开发2.0
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-15T11:25:56+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="搭建-vue-cli-脚手架"><a href="#搭建-vue-cli-脚手架" class="headerlink" title="搭建 vue-cli 脚手架"></a>搭建 vue-cli 脚手架</h2><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="JSONP-的概念"><a href="#JSONP-的概念" class="headerlink" title="JSONP 的概念"></a>JSONP 的概念</h3><ol>
<li>浏览器同源策略的缘故：同一个协议、同一个域名、同一个端口；ajax 中不允许请求非同源的 URL，JSONP 就是来解决这个问题的</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/08/15/项目开发2-0/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/14/AJAX/" itemprop="url">
                  AJAX
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-14T19:29:34+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><ol>
<li>作用： 用于在后台与服务器交流数据，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新</li>
<li>语法： <code>variable = new XMLHttpRequest()</code></li>
</ol>
<h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><ol>
<li>使用 XMLHttpRequest 对象的 open()与 send()</li>
<li>语法： <code>xmlhttp.open(&#39;GET&#39; , &quot;ajax_info.text&quot; , true)</code><ul>
<li>规定请求的类型、URL 以及是否异步处理请求<ul>
<li>method： 请求的类型；GET 或 POST</li>
<li>url： 文件在服务器上的位置</li>
<li>async： true（异步）或 false（同步）</li>
</ul>
</li>
</ul>
</li>
<li>语法<code>xmlhttp.send()</code><ul>
<li>将请求发送发送到服务器上<ul>
<li>string： 仅用于 POST 请求</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="GET-还是-POST"><a href="#GET-还是-POST" class="headerlink" title="GET 还是 POST"></a>GET 还是 POST</h3><ul>
<li>与 post 相比，GET 更简单，并且在大部分情况下都可以使用，在以下情况下使用 post<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据数量限制）</li>
<li>发送包含未知字符的用户输入，POST 比 GET 更加可靠</li>
</ol>
</li>
</ul>
<h3 id="url-服务器上的文件"><a href="#url-服务器上的文件" class="headerlink" title="url-服务器上的文件"></a>url-服务器上的文件</h3><ol>
<li>open 发放的 url 参数是服务器文件额地址<ul>
<li>xmlhttp.open(“GET” , “文件地址”)</li>
</ul>
</li>
</ol>
<h3 id="异步为-TRUE"><a href="#异步为-TRUE" class="headerlink" title="异步为 TRUE"></a>异步为 TRUE</h3><ol>
<li>发送的请求是 AJAX 的时候第三个参数必须为 true ，表示异步获取</li>
<li>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性<ul>
<li>responseText 获得字符串形式的相应数据</li>
<li>responeXML 获得 XML 形式的相应数据</li>
</ul>
</li>
</ol>
<h2 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h2><ol>
<li>当请求被发送到服务器是，我们需要执行一些相应的任务，每当 ready State 改变时，就会触发 onreadystatechange 事件。</li>
<li>三个重要属性<ul>
<li>onreadystatechange： 存储函数或函数名，每当 readyState 属性改变时，就会触发调用还函数</li>
<li>存有 XMLHttpRequest 的状态。从 0~4 发生变化<ul>
<li>0：请求未初始化；</li>
<li>1: 服务器已经建立</li>
<li>2： 请求已经接受</li>
<li>3： 请求处理中</li>
<li>4：请求已经完成</li>
</ul>
</li>
<li>status<ul>
<li>200 : OK</li>
<li>404: 为找到页面</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Junjie Fan">
          <p class="site-author-name" itemprop="name">Junjie Fan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junjie Fan</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
